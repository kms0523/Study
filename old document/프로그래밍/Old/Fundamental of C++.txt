Chapter 1 타입

	<1.2.3. 2의 보수법(2's complement)>
		20p
			- 1의 보수라는 것은 어떤 2진수에서 각 비트를 반전시킨 것을 나타낸다.
			- 2의 보수는 1의 보수에 1을 더한 것을 의미한다.
			- 2의 보수법이란 2의 보수를 음수로 사용하는 방법이다.
		
		22p
			- 4비트에서 2의 보수법은 0000을 0으로 대응시키고, 순서대로 다음 숫자인 0001을 1로 대응시킨다.
			- 반대로 0000의 이전 숫자인 1111은 -1로 대응시키는 방식이다.
			- 또한 음수의 경우 각장 왼쪽 비트가 1이 되므로 자연스럽게 부호 비트 역활을 하게 된다.
	
	<1.2.4. 타입별 최솟값, 최댓값>
		24p
			- signed타입의 경우 최솟값은 맨 왼쪽 부호 비트만 1로 설정하면 된다. 따라서 1을 설정한 뒤에 비트 이동 연산자를 이용하여 왼쪽으로 이동시키면 쉽게 최솟값을 구할 수 있다.
			  최댓값은 최솟값을 비트 반전만 하면 되므로 비트 반전 연산자(~)를 이용하여 구할 수 있다.
			- unsigned 타입의 경우 최솟값은 0이며, 최댓값은 모든 비트가 1로 채워진 것이기 때문에 -1만 대입해주면 된다.
			  https://m.blog.naver.com/PostView.nhn?blogId=alwaysgo&logNo=100165310584&proxyReferer=https:%2F%2Fwww.google.com%2F
			  https://kin.naver.com/qna/detail.nhn?d1id=1&dirId=1040101&docId=66117643&qb=dW5zaWduZWQgaW50&enc=utf8&section=kin&rank=4&search_sort=0&spq=0
			  http://stackoverflow.com/questions/1863153/why-unsigned-int-0xffffffff-is-equal-to-int-1
			  http://stackoverflow.com/questions/50605/signed-to-unsigned-conversion-in-c-is-it-always-safe 
			  http://stackoverflow.com/questions/809227/is-it-safe-to-use-1-to-set-all-bits-to-true
			
	<1.2.5. 비트 이동 연산자(Shift Operator)>
		24p
			- C++에서는 <<, >>라는 연산자를 통해서 원하는 만큼 비트들을 이동시킬 수 있다.
		
		25p
			- char는 문자를 나타내는 타입일 뿐만 아니라 1바이트 크기의 부호 잇는 정수를 나타내는 타입이다.
			- << N : 비트 상태를 N만큼 왼쪽으로 이동시킨다. 가장 왼쪽의 넘치는 비트들은 버리고, 오른쪽에 새로 생기는 비트들은 모두 0으로 채운다.
			- >> N : 비트 상태를 N만큼 오른쪽으로 이동시킨다. 가장 오른쪽의 넘치는 비티들은 버리고, 왼쪽에 새로 생기는 비트들은 부호비트로 채운다.
			
		27p
			- 비트 이동 연산은 정수 타입에 대해서만 유효하다. 
			  부동소수점 타입인 float, double 객체에는 비트 이동 연산을 사용할 수 없다.
			
		
	<1.2.7. 데이터 모델>
		28p
			- 타입은 정보를 비트 상태로 대응시키는 법과 더불어서 크기 또한 나타낸다.
			- 타입에 따른 크기는 플랫폼에 종속적이다. 왜냐하면 각 플랫폼별로 데이터 모델이 다르기 때문이다.
			- 데이터 모델이란 각 타입에 따른 크기가 어떻게 결정되는지를 나타낸다.
			- 데이터 모델의 이름에서 타입의 크기를 알 수 있다. (EX : ILP 32 : int long pointer가 32bit, LLP64 : long long, pointer가 64bit)
			- 어떤 데이터 모델이든지 char, short, long long은 그 크기가 (8, 16 64)로 일정하다.
		
		29p
			- 32비트 시스템에서는 윈도우 리눅스 모두 ILP32 모델을 사용하였다.
			- 64비트 시스템에서는 윈도우는 LLP64 리눅스는 LP64를 채택하였다.

	<1.3 부동소수점 타입>
		31p
			- 부동소수점은 아주 작은 수와 아주 큰 수 양쪽을 아우르는 실수를 표현하기 위하여 도입된것이다.
	
	<1.3.2. 부동소수점과 2진법>
		32p
			- 정수 부분을 2진수로 변환할 때는 2로 나누어서 나머지를 구했는데, 소수 부분의 경우 2를 곱해서 정수 부분을 취하면 된다.
			- 그림 1-6 소수 부분 2진법 변환 
			
	<1.3.3. 부동소수점 구조>
		33p
			- 정규화란 정수부를 1로 맞추어 놓고, 적절하게 소수점 위치를 조정하는 것을 말한다.
			- 정규화를 거친 후에 부호와 가수부(소수부의 유효숫자들) 그리고 지수부만 있으면 된다.
			- 부동소수점 형식은 정해진 비트를 적절히 분배하여 부호부, 지수부, 가수부를 할당하는 일종의 규칙이자 약속이다.
			- 지수부 표현은 바이어스 표현법 구조를 택하였는데 이는 순수한 0을 표시하기 위함이다.
	
	<1.3.4 부동소수점 표현 한계>	
		37p 
			
	<1.3.5 부동소수점 사용시 주의점>
		42p
			- 정수 단위로 큰 수를 정확하게 다루어야 한다면 64비트 정수 타입을 사용해야 한다.
		
		43p	
			- 부동소수점은 반올림에서도 문제가 발생할 수 있다.
			
	<1.3.6 무한 & NaN>
		44p
			- 지수부의 모든 비트가 1로 채워져 있을 경우 무한과 NaN을 표현할 수 있다.
			- 가수부의 모든 비트가 0으로 채워져 있는 경우 무한이며, 하나라도 1이 있을 경우 NaN을 나타내게 된다.
			
	<1.4 문자타입>
		46p
			- char는 철저하게 알파벳 기준으로 만들어진 타입이다.
			- char는 ASCII 인코딩을 사용하여 문자를 비트 상태와 대응시킨다.
			- 알파벳 대소문자, 숫자, 특수문자, 제어문자등으로 이루어져 있으며 다 합친 문자의 개수가 128개라서 7비트만 사용한다. 
			  즉, 맨 왼쪽 비트는 0으로 설정되어 있다.
		
	<1.4.1 유니코드>
		47p
			- 유니코드는 이 세상 모든 문자들에게 코드를 부여한 것이다. 
			  그 코드라는 것은 순수하게 번호를 의미하며, 몇 바이트 크기의 비트 상태를 어떻게 설저앻야 한다는 대응법과는 전혀 상관이 없다.
			  단지 각각의 문자들에게 중복되지 않는 유일한 번호를 부여한 것 뿐이다.
			- 유니코드를 실제 컴퓨터의 타입으로 대응시키는 방식을 UTF-N이라 한다.
			
	< 1.4.2. UTF(Unicode Transformation Format)-N >
		47p
			- UTF-N의 정확한 의미는 N 비트의 배수로 한 문자를 표현한다는 것이다.
			  가령 UTF-8의 경우 8비트로 한 문자를 나타낼 수도 있으나, 경우에 따라서 16비트로 한 문자를 나타내고, 부족하면 24비트로 한 문자를 나타내겠다는 것이다.
			- UTF-8에서 알파벳은 ASCII와 동일하게 1바이트만으로 표시되며 한글의 경우 한 글자가 3바이트를 차지하게 된다.
	
		48p
			- UTF-8은 글자 수를 셀 경우 각 글자마다 바이트 크기가 다르기 때문에 많은 연산을 요구하게 된다.
			- C++는 UTF-16이나 UTF-32를 wchar_t 데이터 타입으로 지원한다.
			- wchar_t는 컴파이럴에 따라서 UTF-16이나 UTF-32에 대응되는데 VC++ wchar_t는 2바이트이며 UTF-16을 지원하며 GCC의 경우 wchar_t는 4바이트로 UTF-32를 지원한다.
			- Wide Character를 표현하기 위해서는 L 매크로를 사용할 수 있다.
			
	< 1.5 문자열 >
		52p
			- 문자열은 문자들이 모인 것으로 특별히 문자열을 위한 타입을 C++에서 제공하지는 않는다.
			- 문자열은 문자 배열로 표현할 수 있다.
			- NULL 종료 문자열(NULL Terminated String)은 문자열 끝에 NULL을 넣어 어디까지가 문자열인지를 판별할 수 있도록 한다,
			
			

	46p
		- ASCII

	47p
		- UTF-N

	54p
		- tolower 과 toupper 알고리즘은 컨테이너의 요소를 하나씩 받아서 처리한다.
		- string 컨테이너의 한 요소는 한 글자가 아니라 char 객체 하나이다.
		- 주로 사용하는 한글의 경우 2바이트 각각의 코드가 ASCII와 겹치지 않으나, 생소한 한글의 2바이트 중 하나가 ASCII와와 중복되면 문제가 발생할 수 있다.
		
	59p
		- 문자열 상수의 타입 변환의 우선 순위는 const char* 그 다음이 char* 이다.

	63p
		- 참조는 일종의 포인터로 동작하며 초기화할 경우 주소 연산자가 생략되고, 직접 사용할 경우에는 간접 연산자가 생략 된다.
		- Reference vs Pointer
			-Reference can't be re-allocated
			-https://www.geeksforgeeks.org/passing-by-pointer-vs-passing-by-reference-in-c/
			-https://www.geeksforgeeks.org/pointers-vs-references-cpp/
			
	65p
		- [소스 1-23]참조 타입 3 - 참조 타입이 있을 때 컴파일러가 작성하는 어셈블리와 스택 구조

	70p
		- typedef 정의 방법 
			- 원하는 타입을 선언한다
			- 선언문 앞에 typedef를 붙인다.
			- 선언문의 객체 이름을 정의하고자 하는 타입 이름으로 변경한다.

		
	기본 자료형의 call by reference ?

Chapter 2 선언과 정의
	79p
		- 해당 객체를 위한 메모리 영역을 확보하는 것이 바로 정의이다.

	80p
		- 프로그램 시작시에 전역 객체는 데이터 영역의 메모리 공간을 차지하게 된다.
		- 지역 객체란 함수 인자를 포함하여 함수 안에서 정의된 객체를 말하며 스택의 메모리 공간을 차지한다
		- 함수의 본체가 있을 경우 함수가 정의되었다고 한다.
		- 컴파일러는 함수 본체를 어셈블리로 변경하고, 변경된 어셈블리는 코드 영역에 저장된다. 따라서, 함수도 일반 객체처럼 메모리의 공간을 차지하게 된다.
		- 정의란 어떤 대상이 실제로 존재할 수 있도록 자리(메모리 영역)를 만들어주는 작업이다.  하지만 클래스의 경우 이 정의의 개념이 달라진다.
		
	81p
		- 클래스 정의란 실제로 이 클래스가 어떻게 구성 되어 있는지를 나타내는 설계도라고 할 수 있다.
		- 기존 변수들이 차지하는 메모리 영역은 프로세스가 사용하는 가상 메모리 영역이지만, 클래스의 설계도가 저장되는 메모리 영역은 컴파일러가 사용하는 메모리 영역이다.
		- 즉 클래스 설계가 저장되는 메모리는 실제 프로그램이 사용하는 메모리와는 전혀 관련이 없다.
		- 클래스 맴버 객체가 선언된다는 의미는 클래스 객체가 생성되어 객체에 대한 메모리가 할당될 경우 할당된 영역의 특정 부분이 멤버 객체에게 할당된단다는 것
	(??)- 클래스 멤버 함수가 선언될 경우 해당 함수가 멤버 함수임을 알리게 되고, 정의될 때는 프로세스 시작시 함수의 본체가 코드 영역의 메모리를 차지하게 됨을 나타낸다. 
		- 정의란 어떤 대상이 존재할 수 있도록 메모리를 할당하는 과정이다.
			일반적인 객체와 함수들의 경우 : 정의에 의해서 가상 메모리가 할당 됨 
			클래스의 경우 : 정의에 의해서 컴파일러가 사용하는 메모리가 할당 됨
		
	82p
		- 선언이란 어떤 객체가 존재하고 있음을 알리는 역활을 한다.
		
	83p
		- 정의는 곧 선언을 포함한다.
		
	84p
		-순수 선언

	85p
		- 어떤 cpp 파일에서 정의를 할 경우 해당 소스 파일에 대해서는 선언까지 자동으로 이루어진다. 
		- 다른 cpp 파일에서 정의된 객체를 사용하고자 할 경우에는 순수하게 선언만 해주어야만 한다.
		- 만일 정의를 중복으로 하게 될 경우 링크 에러가 발생하게 된다. ( 어떤 것을 선택해야만 할 지 알 수 없기 때문 )

	86p
		- 선언과 정의에서 많이 사용되는 키워드는 extern과 static이다.
		- static이란 영역 내부에 고정된 어떤 것을 나타내서 특정 범위에서만 사용할 수 있는 것을 나타낸다.
		- extern이란 영역 외부에 존재하기 때문에 영역 내/외부 모두에서 사용할 수 있음을 나타낸다.
		- extern과 static 객체는 전역 객체의 특성을 가지지만 static 객체는 사용 범위가 한정된다는 측면에서 정적 객체로 표현한다.
		- 객체는 local과 non-local 객체로 나뉘어지며, non-local 객체는 전역 객체와 정적 객체로 나뉘어진다.

	87p
		- extern은 선언만을 할 때도 사용될 수 있지만 애초의 목적은 static과 대비되는 전역 변수를 정의하기 위한 키워드이다. 따라서 정의에도 충분히 사용될 수 있긴 하지만 코드의 간결함을 위하여 보통 extern을 생략할 수 있도록 허용한다.
		- 정적 변수는 정적 변수가 정의된 cpp파일에서만 사용될 수 있다. ( 다른 cpp 파일에서 사용할 경우 링크 에러가 발생한다. )
		- extern의 의미는 정의에 사용될 경우 다른 cpp 파일에서도 사용 가능하도록 링크를 허용하는 것이고, static의 경우 다른 cpp 파일에서는 사용할 수 없도록 링크를 허용하지 않는 것이다.
		
	88p
		- extern이 정의로 사용될 경우 extern은 생략할 수 있으나 extern이 선언으로 사용될 경우 extern은 생략할 수 없다.
		- extern과 함께 초기화가 이루어지는 경우 정의라고 할 수 있다.
	
	89p
		- 관례적으로 정의를 할 경우에는 extern 키워드를 생략하며, 선언을 할 때 extern을 사용한다.
		
	<2.14	 클래스 선언과 정의>
		89p
			- 클래스라는 것은 일종의 설계도로서 다른 객체와는 완전히 성격이 다른 것을 나타낸다.
			- 일반적으로 객체나 함수가 가상 메모리 영역을 차지하는 것에 비하여 클래스는 오직 개념적인 구조로서만 존재할 뿐이다.

		90p
			- 클래스가 선언되어 있긴 하지만 그것은 클래스라는 것을 알려줄 뿐이지, 클래스가 어떤 크기를 가지고 어떤 멤버로 이루어져 있는지는 전혀 알려주지 못한다.
			- 클래스의 정의는 오직 정의된 cpp파일에서만 알려지게 된다.
			- 컴파일러는 오직 cpp 단위로만 독립적으로 컴파일을 하기 때문에 에러가 발생한다.
			
		91p
			- 결국 클래스 객체를 정의하기 위해서는 클래스 정의가 필요할 수밖에 없으며 클래스의 정의는 각 cpp 파일마다 정의되어야만 한다. 따라서 클래스의 정의는 다른 일반 객체나 함수의 정의와는 다르게 중복을 허용할 수 밖에 없다.
		
		94p
			- 클래스의 멤버 변수에 접근하는 것은 클래스 설계도(정의)에 따라 해당 멤버 변수의 메모리 오프셋에 의해서 계산된 위치를 기준으로 한다.
			- 멤버 변수의 이름은 오직 오프셋 계산을 위해서 사용되는 것이지, 그 자체가 하나의 고정된 영역을 나타내는 것은 아니다.
			- 클래스가 같은 이름으로 중복 정의되고 정의가 다를 경우에는 분석하기 어려운 버그가 발생할 수 있다.
			- 클래스 이름만 같고 정의가 완전 다른 경우에는 런타임 에러가 발생하지만, 정의가 유사하고 약간 다를 경우 문제를 찾기 어려울 수 있다.
			- 클래스 중복 정의 문제를 피하기 위해서는 이름을 단순하지 않게 지을 필요가 있으며 namespace를 사용하여 원천적으로 이름 중복이 발생할 가능성을 막는 것이다.
	
	
	< 2.2 기억 부류(storage class) >
		94p
			- 메모리 영역은 가상 메모리로서 크게 코드 및 데이터, 힙, 스택으로 나누어질 수 있다.
			- 전역(정적 포함) 객체의 경우 모두 데이터 영역에 저장되고, malloc 및 new와 같은 동적 메모리 할당 연산자에 의해서 생성된 객체들은 힙에 저장된다. 또한 함수 안에서 정의 되는 지역 변수나 인자들은 스택에 저장된다.
		
		95p
			- 기억 부류에 의해서 객체들의 생성과 소멸 시점이 결정되며 초기화 방식 및 통용 범위가 정해지게 된다.
			
	< 2.2.1. 논리공간 >
		95p
			- 실행 파일(EXE) 및 동적 라이브러리(DLL, SO)가 존재하는 가상의 논리적인 공간을 '실행 공간'이라고 부르기로 한다.
			- 즉, 빌드(컴파일 + 링크) 과정을 거쳐서 실행 파일이나 동적 라이브러리가 생성될 때 비로서 실행 공간이 탄생하게 되는 것이다.
			- 컴파일러는 cpp 파일 하나씩 컴파일을 하여 obj 파일을 만들어내며, 링커가 목적 파일들을 적절히 링크하여 결과적으로 하나의 실행 파일이 된다.
			- 각각의 cpp 파일에 의해 생성되는 obj 파일들이 존재하는 가상의 논리적인 공간을 '오브젝트 공간'이라고 부르기로 한다.
			- 결국 실행 공간은 오브젝트 공간들의 모임으로 이루어진다.
			
		99p
			- 같은 이름의 전역 변수는 실행 공간에 오직 단 한번만 정의될 수 있다
			- 같은 이름의 정적 변수는 각각의 오브젝트 공간에 오직 단 한번만 정의될 수 있다. 따라서 실행 공간에는 같은 이름의 정적 변수가 여러 번 정의될 수 있는데 각각은 완전히 서로 다른 개별적인 변수이다.
			- 같은 이름과 같은 인자 타입을 가진 전역 함수는 오브젝트 공간에 단 한 번만 정의될 수 있다. 또한 같은 이름과 같은 인자 타입, 같은 반환 타입을 가진 함수는 실행 공간에 단 한 번만 정의될 수 있다.
		
		100p
			- 같은 이름의 클래스는 각각의 오브젝트 공간에 오직 단 한 번만 정의될 수 있다. 따라서 실행 공간에 같은 이름의 클래스가 여러 번 정의될 수 있지만 만일 구조가 다를 경우 런타임에 문제를 발생시킬 소지가 있다.
			
	< 2.2.2. 변수 할당과 초기화 >
		100p
			- 변수는 정의되면서 메모리 영역을 할당 받으며 동시에 해당 메모리 영역이 특정 값으로 채워지는 초기화가 이루어지기도 한다.
		
		101p
			- 정적 변수를 포함한 전역 변수는 프로세스가 시작 되고 가상 메모리 영역이 설정될 때 데이터 영역에 메모리를 할당받는다.
			- 지역 변수의 메모리 할당은 함수가 실행되는 시점에 이루어진다. 왜냐하면 지역 변수가 위치하는 메모리 영역은 스레드 스택으로 함수가 실행되는 순간에 함수 안에서 정의된 지역 변수를 위하여 스택이 늘어난다. 
			
		102p
			- 전역 및 정적 객체가 존재하는 메모리 영역은 가상 메모리의 데이터 영역이다. 가상 메모리 중에서 코드와 데이터 영역은 어떤 순서를 가지고 가상 메모리로 올라오는 것이 아니다. 즉, 순서가 의미가 없다.
			- 함수 안에서 사용되는 모든 지역 변수들의 크기를 먼저 구한 뒤에 함수 실행 시점에 스택을 늘리기 때문이다.
			- 함수의 인자도 스택 메모리에 할당되지만, 인자의 경우는 함수가 호출되기 직전에 스택을 늘리면서 영역을 확보하게 된다.
			- 어셈블리로 따진다면 함수 call 명령어 전에 인자의 영역이 스택에 먼저 생성되고, 함수 안에서 정의된 지역 변수들이 그 다음에 스택에 생성된다.
			- 전역 및 정적 객체의 메모리 할당 순서는 큰 의미가 없지만 초기화의 경우는 순서가 중요해진다.
			
		103p
			- 프로세스가 실행된다는 것은 곧 스레드가 실행된다는 것이다. 그리고 스레드가 실행하는 것은 바로 함수이다.
			- 프로세스가 실행되면서 최초로 CRT Startup 함수가 실행된다.
			
		104p
			- CRT Startup이 main 함수를 호출하게 된다. 참고로 CRT Startup은 main을 호출하기 전에 다른 많은 작업을 한다.
			- 상수로 초기화하는 전역 변수의 경우 메모리 영역이 할당되는 순간에 해당 상수 값으로 초기화가 진행된다.
			  이것이 가능한 이유는 초기화 값이 상수인 경우, 컴파일러에 의해서 실행 이미지의 데이터 영역에 직접 값을 설정할 수 있으며, 프로세스가 실행되는 순간에 해당 이미지의 데이터 영역이 그대로 가상 메모리에 올라오기 때문이다.
			- 초기화하지 않은 전역 변수의 경우는 기본적으로 0(NULL) 값으로 초기화되는데, 초기화하지 않은 전역 변수의 경우는 BSS 영역에서 가상 메모리로 올라올 때 0(NULL)으로 초기화가 이루어진다.
			- 전역 변수는 초기화 하지 않은 것과 상수로 초기화한 것이 가장 먼저 초기화 값으로 설정되며 그 다음으로 함수의 반환을 통한 초기화가 이루어진다.
			  참고로 함수를 통해서 전역 변수를 초기화하는 경우 해당 함수들을 호출해주는 초기화 함수가 존재하며, CRT Startup이 main을 호출하기 전에 먼저 초기화 함수를 호출한다.
			- 전역 변수와는 상관없이 함수 안에서 정의되는 지역 변수의 초기화는 코드의 순서대로 이루어진다.
			
	< 2.2.3. 변수 초기값 >
		105p
			- 초기화를 하는데도 CPU를 사용하기 때문에 초기화할 변수가 많으면 많을수록 효율이 떨어지게 된다.
			- 스택 메모리는 이전에 설정된 값들이 남아있기 때문에 현재 어떤 값이 들어있는지 알 수가 없다.
		
		106p
			- 전역 변수와 정적 변수는 데이터 영역에 위치하게 된다.
			  이 데이터 영역은 다시 두 부분으로 나뉘어지는데 초기화된 데이터 영역( Data 영역 )과 초기화되지 않은 데이터 영역( BSS(Block Stated Symbol) 영역 )으로 나누어진다.
			- 상수로 초기화하게 되면 가상 메모리가 구성되는 시점에 이미 초기화가 되어있다.
			- 데이터 영역은 0이 아닌 상수로 초기화된 전역 변수들이 위치하는 공간이다.
			- BSS 영역은 가상 메모리가 구성되는 시점에 모두 0으로 채워지는 영역이다.
			- 초기화 없는 전역 변수나, 기본값(NULL , 0)으로 초기화 전역 변수는 BSS영역에 위치하며 프로세스 시작시 초깃값으로 0을 가지게 된다.
			- 함수 초기화 전역 변수는 BSS영역에 위치하게 되는데, 가상 메모리가 모두 구성된 이후 최초의 스레드가 CRT Startup을 수행하고 CRT Startup이 초기화 처리 함수를 호출할 때, 초기화 처리 함수가 함수를 호출하면서 초기화가 된다.
			
			
			



