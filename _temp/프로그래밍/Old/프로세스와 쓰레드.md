# 운영체제

## 프로그램
프로그램이란 보조 기억장치(HDD,SSD)에 저장되어 있지만 메모리 공간을 할당 받지 않은 정적인 상태의 파일(명령어와 데이터의 묶음)이다.

## 프로세스
프로세스란 운영체제로부터 독립적인 메모리 공간을 할당 받은 동적인 상태의 파일(명령어와 데이터 묶음)이다.  
이때 프로그램에서 프로세스로의 전환과정은 다음과 같다.
1. 사용자가 프로그램 실행
2. 운영체제가 코드와 데이터를 메모리에 가져오고, 프로세스 제어블록(PCB, Process Control Block) 생성

이후 프로세스는 다음의 과정을 거쳐 실행이 된다.
1. 준비 상태의 프로세스를 준비 리스트에 삽입
2. CPU가 사용 가능한 상태가 되면 CPU 스케쥴러(scheduler)에 의해 선택된 프로세스에게 디스패처(dispatcher)가 CPU를 할당하고 프로세스는 실행 상태로 상태전이(state transition)이 된다. 이 과정을 디스패칭(dispatching)이라 한다.
3. 프로세스가 CPU를 이용해 연산한 후 반납
   1. CPU를 자발적으로 반납 (nonpreemtive scheduling 비선점형 스케쥴링)
   2. 우선순위에 따라 운영체제에 의해 반납 (preemtive scheduling 선점형 스케쥴링)
4. 작업이 끝나지 않았으면 운영체제가 프로세스를 준비 상태로 상태전이
5. 만약 입출력이 완료대기를 기다려야 하는 상황이라면 완료될때까지 블록 상태로 상태전이
6. 입출력이 완료되면 운영체제가 프로세스를 블록 상태에서 준비 상태로 상태전이
7. 운영체제는 다시 준비 리스트에 첫번째에 있는 프로세스를 실행상태로 바꾸고 과정을 반복

만약 프로세스가 여러개의 스레드로 구성되어 있다면 위의 과정에서 프로세스를 스레드로 바꾸어 보면 된다. 즉, 하나의 프로세스에 각 스레드별로 다른 상태(준비,실행,블락)를 가질 수 있다 [[참고]](https://junsday.tistory.com/25).

### PCB
PCB는 프로세스에 대한 정보가 저장된 자료구조이며 운영체제 영역에서 만들어지며 [[참고]](https://velog.io/@cheal3/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C) 구성요소는 다음과 같다. [[참고]](https://bowbowbow.tistory.com/16#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B5%AC%EC%84%B1)

#### 1.PID, Process IDentification   
운영체제가 각 프로세스를 식별하기 위해 부여한 프로세스 식별번호

#### 2.프로세스 상태  
CPU는 프로세스를 빠르게 교체하면서 실행하기 때문에 실행중인 프로세스도 있고 대기 중인 프로세스도 있다. 그런 프로세스의 상태를 저장

#### 3.프로그램 카운터  
CPU가 다음으로 실행할 명령어를 가리키는 값. CPU는 기계어를 한 단위씩 읽어서 처리하는데 프로세스를 실행하기 위해 다음으로 실행할 기계어가 저장된 메모리 주소를 가리키는 값.

#### 4.스케줄링 우선순위  
운영체제가 여러 개의 프로세스가 CPU에서 실행되는 순서를 결정하는 것이 스케줄링이다. 이 스케줄링에서 우선순위가 높으면 먼저 실행될 수 있는데 이를 스케줄링 우선순위라고 한다.

#### 5.권한  
프로세스가 접근할 수 있는 자원을 결정하는 정보. 안드로이드 앱을 예로 들면 아무 앱이나 휴대폰 통화내역을 볼 수 있는 권한을 가지면 이를 악의적으로 이용하는 앱이 등장하겠죠? 그래서 프로세스마다 어디까지 접근할 수 있는지에 대한 권한이 필요합니다

#### 6.프로세스의 부모와 자식 프로세스  
최초로 생성되는 init 프로세스를 제외하고 모든 프로세스는 부모 프로세스를 복제해서 생성되고 이 계층관계는 트리를 형성합니다. 그래서 각 프로세스는 자식 프로세스와 부모프로세스에 대한 정보를 가지고 있습니다.

#### 7.프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터
프로세스는 실행중인 프로그램입니다. 따라서 프로그램에 대한 정보를 가지고 있어야합니다. 프로그램에 대한 정보는 프로세스가 메모리에 가지는 자신만의 주소 공간에 저장됩니다. 이 공간에 대한 포인터 값을 가집니다.

#### 8.프로세스에 할당된 자원들을 가리키는 포인터

#### 9.실행문맥(context)
프로세스가 실행상태에서 마지막으로 실행한 프로세서의 레지스터 내용을 담고 있습니다. CPU에 의해 실행되는 프로세스는 운영체제에 의해 계속 교체되는데 교체되었다가 다시 자신의 차례가 되어서 실행될때 중단된적 없고 마치 연속적으로 실행된것처럼하기 위해 이 레지스터 정보를 가지고 있습니다.

### 다수의 실행 흐름
하나의 프로세스는 하나의 실행 흐름만을 가질 수 있다. 이 떄, 다수의 실행 흐름이 필요하여 [[예시]](https://jhnyang.tistory.com/368) 여러개의 프로세스를 구성한 경우 다음과 같은 문제점이 있다.

1. 독립된 메모리 영역을 가지고 있어 프로세스 간의 복잡한 통신(inter process communication, IPC)가 필요하다.
2. context switching시 기존 프로세스에 할당된 메모리 영역을 저장하고 새로운 프로세스의 메모리 영역을 불러와야 하기 때문에 overhead가 크다.

이를 해결하기 위해 나온 개념이 스레드이다.

#### 참고
[블로그](https://so-what-93.tistory.com/41) -> 여기 보고 추가로 정리하기

## 스레드
스레드는 하나의 프로세스 내에서 여러개의 실행 흐름을 두기 위해 나온 개념으로 프로세스의 실행 단위이며 하나의 프로세스에 여러개의 스레드로 구성될 수 있다.

### 멀티 스레드
하나의 프로세스가 여러 스레드로 구성되어 있는 것

멀티 프로세스 대비 장점
* 프로세스 내에 여러 스레드는 stack과 레지스터를 제외한 메모리 영역을 공유하기 때문에 공유 메모리 영역을 통해  스레드 간의 통신을 간단히 할 수 있다.
* 스레드의 context switching은 기존 스레드의 stack만 저장하고 새로운 스레드의 stack만 불러오면 되기 때문에  프로세스의 context switching에 비해 overhead가 상대적으로 적다.

싱글 스레드 대비 장점
* 프로세스 내의 한 스레드가 다른 작업을 수행중이더라도 다른 스레드가 사용자의 작업 요구에 응답이 가능하기 때문에 응답성이 향상된다.
* 다중 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티 스레드를 동시에 처리하여 프로세스의 처리 시간이 단축된다.

단점
* 서로 다른 스레드가 동시에 같은 메모리에 접근하여 읽고 수정하는 경우 경쟁 상태가 발생할 수 있다.
* 하나의 스레드에서 발생한 문제가 동일 프로세스 내의 다른 스레드로 확산될 수 있다.

멀티 스레드의 경쟁상태를 해결하기 위해 뮤텍스 개념이 사용된다.

### 뮤텍스
여러 스레드가 동시에 코드를 실행하지 못하게 std::mutex 객체에서 lock과 unlock 메서드를 제공한다. mutex 객체의 lock과 unlock 메서드 사이의 코드 영역을 `임계 영역(critical section)`이라고 한다.

`데드락(dead lock)`이란 mutex를 lock하지 못해 모든 스레드들이 연산을 진행하지 못하고 무한정 대기하는 상태이다. 데드락이 발생할 수 있는 상황은 첫번째로 mutex 객체로 lock 메서드를 호출한 후 unlock 하지 않은 경우이다. 이 경우는 std::lock_guard 객체를 사용할 경우 소멸자에서 mutex 객체를 자동으로 unlock하게 하여 해결할 수 있다. 두번째 경우에는 중첩된 lock을 다른 순서로 다른 함수에서 사용할 경우 mutex lock 메서드 호출 후 unlock 메서드를 호출 했음에도 lock이 얽히는 경우이다. 이 경우는 특정 뮤텍스에 우선순위를 주어 해결할 수 있지만 이 경우 특정 스레드만 많은 일을 하게 되는 기아 상태(starvation)이 발생할 수 있다. 따라서 애초에 중첩된 lock을 사용하지 않거나 lock을 언제나 정해진 순서로 획득해야 한다.

## 멀티테스킹
하나의 CPU에서 운영체제의 스케쥴링에 따라 여러 프로세스를 번갈아 가며 실행을 이용하여 `동시성(concurrency)` 있게 처리함. 여기서 동시성이란, 물리적인 시간의 동시성이 아니라 사용자 입장에서 마치 동시에 처리되는 것처럼 느껴 진다는 의미이다.

멀티 테스킹시 한 프로세스에서 발생한 입출력 함수(I/O)를 기다리느라 CPU가 연산하지 않고 I/O가 끝날때 까지 대기하는 비효율이 발생한다. 이를 해결하고 CPU의 이용률을 높이기 위해 사용하는 스케쥴링 방식에는 멀티 프로그래밍 시스템과 시분할 시스템 방식이 있다.

### 멀티 프로그래밍 시스템
한 프로세스에서 I/O를 호출했을 때 I/O 장치에 데이터가 없을 경우 다른 프로세스로 context switching이 일어난다. 이후 I/O 장치에 데이터가 도착했을 경우, 우선순위에 따라 context switching이 발생한다.  
따라서 멀티 프로그래밍 시스템에서 context switching이 발생하는 상황은 다음과 같다.
1. 현재 실행 중인 프로세스의 종료
2. 현재 실행 중인 프로세스의 I/O로 인한 대기
3. I/O 장치에 기다리던 데이터 도착

장점
* time slice에 의한 CPU스위칭이 없어 CPU 이용률이 최대화된다.

### 시분할 시스템
멀티 프로그래밍 시스템이 context switching이 발생하는 상황에 추가로 프로세스가 일정 시간(time quantum, time slice)이상 CPU를 사용하는 경우에도 context switching이 발생한다.  

context switching 발생 상황
1. 현재 실행 중인 프로세스의 종료
2. 현재 실행 중인 프로세스의 I/O로 인한 대기
3. I/O 장치에 기다리던 데이터 도착
4. tie slice동안 I/O 없이 계속 실행된 경우

장점
* time slice에 의한 CPU 스위칭이 발생해 번갈아가면서 프로그램을 계속 실행하여 사용자 응답성이 높아진다.

## 멀티 프로세싱
하나 이상의 프로세스를 여러개의 CPU가 `병렬적(parallelism)`으로 작업하는 것