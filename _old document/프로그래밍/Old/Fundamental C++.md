# Chapter 03 빌드
결국 프로그래밍을 한다는 것은 소스 코드를 작성하고 그것들을 빌드하여 바이너리를 만들어내는 것이다. `(126)`

## 3.1. 빌드의 구성
빌드는 크게 세 단계로 나눠질 수 있다. 전처리, 컴파일, 링크. 물론 정적 라이브러리를 생성하는 경우에는 링크 과정이 필요하지 않다. 결국 최종 목적의 바이너리(실행 파일, 동적 라이브러리, 정적 라이브러리 등)를 만들어내기 위하여 거치는 과정(전처리, 컴파일, 링크 등) 모두를 '빌드'라고 말한다. `(127)`

빌드를 수행하는 주체는 컴파일러이다. 컴파일러는 이름만 보면 컴파일만 해야 될것 같지만 보통 빌드 전 과정을 수행하는 프로그램을 일컫는 말이기도 하다.

### 3.1.1. 컴파일
컴파일의 대상이 되는 파일은 바로 소스 파일 즉, cpp파일이다. 헤더 파일은 컴파일의 대상이 아니다. 헤더 파일은 오직 특정 cpp 파일 안의 #include 구문에 의해서 포함될 뿐이다. 즉, 특정 cpp 파일이 컴파일되면서 #include에 의해서 포함된 헤더 파일의 내용이 같이 컴파일되는 것뿐이다. 즉, 헤더 파일은 단독으로 컴파일되지 않는다.

소스 파일(cpp)이 컴파일되면 목적(object) 파일이 생성된다. 소스파일과 목적파일은 일대일 대응 관계라고 할 수 있다. ... 소스 파일은 C++ 프로그래밍 문법으로 이루어진 파일이다. 사람이 짠 코드이고, 사람이 이해할 수 있는 것이다. 이 소스 파일을 기계가 읽을 수 있도록 바이너리로 변환된 것이 바로 목적 파일이다. 즉, 컴파일이란 사람이 이해할 수 있는 C++ 언어가 기술된 cpp 파일을 기계가 이해할 수 있는 바이너리 파일로 변환하는 것을 의미한다. `(128)`



# Chapter 04 메모리
프로그램이 실행된다는 것은 간단하게 CPU가 메모리에 값을 읽거나 쓰는 과정으로 바꿔 말할 수 있다. 물론 파일이나 네트워크에 연결하는 과정도 있겠지만 이런 과정 또한 내부에서는 CPU와 메모리 간의 상호 작용이 밑바탕이 되면서 이루어진다.`(153)`

변수를 생성하고, 스레드가 실행하는 함수가 변수의 값을 읽거나 쓰고, 가끔씩 출력하고, 대부분이 그런 과정이다. 변수와 더불어서 스레드가 실행하는 함수 코드조차 어딘가에 저장되어 있어야만 한다. ... 모니터에 출력되어야 할 데이터도 어딘가에는 저장되어 있어야만 한다. 결국 프로그래밍의 기초를 이루는 대부분의 것들이 저장되어야만 하고, 그런 대부분의 것들이 저장되는 장소가 바로 메모리이다.

DRAM이 바로 정보들이 저장되는 메모리의 실체이기도 하지만 프로그래밍에서 언급되는 메모리와는 거리가 좀 있다. DRAM은 물리적인 메모리를 의미하지만 프로그래밍에서 말하는 메모리는 바로 논리적인 가상 메모리를 의미하기 때문이다.`(154)`

## 4.1 가상 메모리
가상 메모리의 핵심은 각각의 프로세스에게 메모리 공간이 독립적으로 부여된다는 것이다. 일반적으로 x86 시스템에서 개별 프로세스는 4GB의 메모리 공간을 부여 받으며 부여 받은 메모리 영역은 해당 프로세스만이 접근할 수 있도록 보호된다. 즉, 메모리 영역이 프로세스에게 독립적으로 부여되기 때문에 타 프로세스가 해당 메모리 영역을 침범할 수 없다는 것을 의미한다. 이런 점으로 인해서 가상 메모리는 프로그램의 안정성을 크게 향상시킬 수 있었다.`(155)`

### 4.1.1 가상 메모리 크기
x86은 32비트 시스템이다. 주소를 가리킬 수 있는 레지스터의 크기가 32비트라는 의미이다. 즉, 이론적으로는 $2^{32}$ 대략 42억 개의 주소가 나오게 된다. 각각의 주소가 1바이트씩 가리킬 수 있으므로 각각의 프로세스는 4GB의 메모리를 부여 받게 된다. 윈도우의 경우 프로세스에게 부여된 4GB의 절반은 운영체제가 사용하며 나머지 2GB의 공간을 프로세스가 스스로를 위하여 사용하게 된다. 즉, 프로세스에게 부여된 메모리 공간은 4GB이지만 실제 사용할 수 있는 메모리 공간은 2GB가 된다.

마찬가지로 x64는 64비트 시스템이며 레지스터의 크기가 64비트이므로 이론적으로 $2^{64}$ 개의 주소를 사용할 수 있기 때문에 대략 16EB$(2^4 \times 2^{60})$byte의 메모리 공간이 부여될 수 있다. 사실상 무한한 메모리 공간이라고 할 수 있는데, 아직까지 이렇게 큰 메모리 공간이 필요한 프로그램이 존재하지 않기 때문에 운영체제별로 다르긴 하지만 윈도우의 경우 프로세스마다 대략 8TB의 공간만을 부여하도록 제한하고 있다. 여기서도 운영체제와 프로세스는 부여된 메모리 공간을 절반 사용하게 된다.

### 4.1.2. 가상 메모리 주소
병원 예시`(156)`
* 병원 - 운영체제
* 병동 - 프로세스
* 병실 - 물리 메모리
* 가상으로 부여된 병실 - 프로세스에 부여된 가상 메모리
* 가상으로 부여된 병실 번호 - 프로세스에 부여된 가상 메모리의 주소
* 호텔의 방 - 2차 저장영역(SSD, HDD)의 페이징 혹은 스왑 파일

메모리는 일정한 크기 단위로 할당된다. 시스템마다 다를 수 있지만 일반적으로 4KB의 메모리 덩어리를 기준으로 하여 가상 메모리에서는 이것을 `페이지(Page)`라고 부르고, 물리 메모리에서는 `페이지 프레임(Page Frame)`이라고 부른다.`(157)`

각 프로세스는 `페이지 테이블(Page Table)`을 가지고 있다. 페이지 테이블에는 가상 메모리의 각 페이지가 현재 물리 메모리의 어떤 프레임에 연결되는지가 테이블 구조로 기록 된다.

물리 메모리가 두개의 프로세스에서 동시에 사용 될 수 있는데 이것은 공유 메모리의 일종으로 보통 윈도우의 dll 혹은 리눅스의 so를 사용할 때 나타나게 된다.`(158)`

### 4.1.3. 가상 메모리 구조
실제 C++ 프로그래밍에서 중요한 것은 '프로세스는 오직 가상 메모리만을 바라본다.'는 것이다. ... 정리하자면 C++ 프로그래밍에서 말하는 메모리란 바로 프로세스의 가상 메모리를 의미한다.

...실제 프로세스가 사용하는 메모리 영역을 프로세스 메모리 영역이라고 부르기도 한다.

가상 메모리의 프로세스 영역은 저장되는 정보의 성격에 따라서 4~5가지로 나눠질 수 있다.`(159)`
#### Code(Text) 영역
이 영역에는 소스 코드 그 자체가 저장된다고 할 수 있다. 보통 함수나 상수 등이 저장된다. 이 영역은 오직 읽기만 가능한 데, 쓰기가 금지되는 이유는 코드의 안정성을 위해서이다. 만일 이 영역에 쓰기가 가능하다면 악의적인 목적으로 실행 코드 자체를 변조할 수 있다.

#### Data와 BSS영역
전역변수와 전역 배열이 저장되는 곳이다. 전역 변수에는 static 변수도 포함됨을 주의하자. 보통 static 변수를 정적 변수라고 표현해서 전역 변수와는 다른 것처럼 알고 있기도 하지만 정확히 얘기하면 전역 정적 변수라고 표현하는 것이 옳다. 즉, 같은 전역 변수이지만 접근 속성이 다른 변수라고 생각하면 된다.

전역 배열이라는 단어가 생소할 수도 있는데 배열이 변수는 아니기 때문에 따로 표현한 것이다. 보통 배열도 변수라고 통칭하는 경향이 있긴 하지만 엄밀히 말해서 배열은 변수가 아니라 상수 포인터이다. 그래서 필자는 보통 전역 변수나 전역 배열 등을 통칭해서 전역 객체라고 표현하기도 한다.

Data의 경우 초기화된 전역 객체가 저장되는 곳이고, BSS는 초기화되지 않은 전역 객체가 저장되는 곳이다. 초기화되지 않았다고 해서 쓰레기 값이 들어있는 것은 아니다. 기본적으로 메모리가 모두 0으로 채워진다.

##### 가상 메모리 구성 과정
소스 코드를 작성하여 빌드(컴파일 + 링크)를 거치면 실행 파일(exe, dll, so)이 생성된다. 프로세스는 실행 파일이 실행되면서 시작된다. 완전히 일치하지는 않지만 실행 파일의 내용은 가상 메모리에 비슷한 구조로 올라가게 된다. 가상 메모리의 프로세스 영역이 Code, Data, BSS 영역으로 나누어져 있듯이 실행 파일의 구조도 비슷하게 여러 영역으로 분할되어 있다. 즉, 실행 파일에도 Code, Data, BSS에 대응되는 영역이 이미 존재한다는 의미이다. ... 실제로 Code나 Data 영역은 실행 파일에서 가상 메모리로 비슷하게 올라간다. 그러나 BSS에 해당하는 영역은 그렇지가 않다.

... 결국 초기화 여부는 객체 자체의 내용을 저장하느냐, 빈 객체가 있다는 사실을 저장하느냐의 차이라고 할 수 있다. 그래서 실행 파일의 데이터 영역에는 실제 초기화된 값들이 저장되어 있지만, 실행 파일의 BSS 영역에는 어떤 객체 들이 필요한지가 저장되어 있다.`(160)`

실행 파일의 BSS 영역에는 초기화되지 않은 32MB 크기의 배열 객체가 있다고 가정해보자. 이것을 그대로 저장한다면 실행 파일은 32MB 이상이 될 것이다. 이것은 무척 낭비가 심하다. 실행 파일의 BSS 영역에는 단지 '32MB 크기의 초기화되지 않은 배열 객체가 있다.'는 정보만 기록하고 있으면 된다. 따라서 32MB의 크기를 포함할 필요가 없다.

이제 프로세스가 시작되면서 실행 파일의 내용이 가상 메모리에 올라가게 된다. OS는 실행 파일의 Code와 Data 영역을 그대로 가상 메모리에 복사하지만, BSS 영역에 대해서는 조금 다른 처리를 수행할 것이다. 배열 객체의 크기인 32MB의 메모리를 확보하고 0으로 채워 넣는 것이다. 초기화 되지 않은 전역 객체는 수없이 많을 수 있다. 따라서 하나의 영역에 몰아놓고, 통째로 해당 영역을 0으로 초기화하는 것이 더욱 효율적일 것이다. 그래서 초기화되지 않은 전역 객체에 대해서는 하나의 영역을 만들게 된 것이고, 그것이 바로 가상 메모리의 BSS 영역이다.

#### Heap & Stack
Heap과 Stack이 서로 반대 방향으로 자라나고 있는 그림은 아주 옛날 싱글 스레드만 지원되던 C언어 시절의 구조이다. 현재 프로세스의 가상 메모리 구조에서는 Heap과 Stack이 양분되어서 위치하는 것이 아니라 메무리 주소가 뒤섞여있는 채로 존재할 수 있다.`(161)`

Stack은 스레드당 하나씩 생성된다. 컴파일러 설정에 따라 다를 수 있지만 보통 기본적으로 스레드당 1MB~4MB 정도의 메모리 영역이 스레드 Stack 공간으로 할당된다. 스레드가 생성되는 순간 운영체제는 가상 메모리의 남은 영역 중에서 적당한 곳을 골라서 스레드 Stack으로 할당해준다. Stack에는 스레드가 실행하고 있는 함수의 인자나 지역 변수, 지역 배열 등이 저장된다. Stack은 함수가 실행되면서 크기가 자라나는데 함수가 종료되면서 다시 크기가 원래대로 줄어들게 된다.

Heap은 동적 메모리가 저장되는 곳이다. ... Heap은 하나의 커다란 메모리 영역이며, 프로세스에 하나 이상 존재할 수 있다. C/C++ 프로그램의 경우 CRT(C Runtime Library)에서 사용하는 CRT Heap이 프로그램 시작시 기본 생성된다. CRT는 자신의 Heap을 사용해서 malloc, new등을 처리한다. Heap이 꼭 프로세스에 하나만 존재해야 한다는 제한은 없다. 사용자의 필요에 의해서 추가로 Heap을 생성할 수도 있다. 일반적으로 각 운영체제의 메모리 관련 API를 사용하여 사용자 Heap을 생성할 수도 있다. Heap은 Heap 관리자에 의해서 다루어진다. Heap 관리자가 최초에 가상 메모리로부터 메모리 덩어리를 할당 받은 후 new나 malloc 요청이 올 경우 적절하게 메모리 영역을 분할하여 넘겨준다. 넘겨줄 부분이 부족할 경우 Heap의 크기를 늘리기도 한다. 또한 free나 delete 요청이 올 경우 넘겨준 메모리 영역을 회수하기도 하며 필요에 따라서 Heap 크기를 줄이기도 한다.

## 4.2. 메모리 할당과 해제
C++ 프로그램에서 동적으로 메모리를 할당 받기 위해서는 malloc, new와 같은 메모리 할당 함수를 호출해야만 한다. 그런데 생각해볼 것이 있다. 메모리를 관리하는 것은 전적으로 운영체제의 몫이다. 윈도우나 리눅스에 따라서 그리고 각각의 버전에 따라서 메모리를 관리하는 방법은 달라질 수 있다. 그럼에도 malloc이나 new를 사용하게 되면 운엥체제의 차이를 뛰어넘어 메모리를 아주 쉽게 할당 받을 수 있게 된다.`(162)`

### 4.2.1. 메모리 할당의 근원
프로세스가 가상 메모리를 할당 받기 위해서는 해당 운영체제에게 메모리 요청을 해야만한다. 또한 이미 살펴본 것처럼 가상 메모리는 페이지 단위로만 할당 받을 수 있다. 당연히 운영체제는 가상 메모리 할당을 위해서 메모리 할당 API나 시스템 콜을 제공하고 있다. 윈도우의 경우 VirtualAlloc이라는 API를 제공하며 리눅스의 경우 완전히 일치하지는 않지만 brk나 mmap이라는 시스템 콜을 제공해준다.

결국 C/C++의 CRT가 제공하는 malloc, new의 근원은 운영체제의 메모리 할당 API나 시스템 콜이라는 것이다. CRT Library는 각각의 운영체제에 맞게 제공되며 그 내부에서 해당 운영체제에 맞는 API나 시스템 콜을 호출하고 있다.

malloc, new가 그대로 VirtualAlloc이나 brk,mmap을 바로 호출하는 것은 아니다. 더 정확히 얘기한다면 malloc, new는 Heap 관리자에 의해서 처리된다. Heap 관리자는 프로세스 시작시 운영체제를 통해서 가상 메모리를 큰 덩어리로 할당 받아 놓는다. 그리고 malloc이나 new가 요청될 때 적절히 할당 받은 메모리를 분할하여 돌려주는 것이다. 물론 페이지 크기를 넘어서는 메모리를 요청할 경우 Heap 관리자는 직접 VirtualAlloc이나 mmap을 호출 할 수도 있다. Heap 관리자는 메모리 단편화를 피하면서 최적의 효율을 내기 위하여 CRT Library에 따라서 구조나 동작 방식이 조금씩 달라지기도 하지만 보편적으로 사용되는 malloc이나 new 사용 패턴에 대하여 최적의 성능을 발휘하도록 설계되어있다. 물론 특정한 방식의 메모리 할당에 최적의 성능을 내기 위하여 직접 사용자 Heap을 생성하고, Heap 관리자를 개발하는 경우도 간혹 있긴 하지만, 정말 특수한 경우라고 할 수 있다.

### 4.2.2. malloc & free
```cpp
void* malloc(size_t size);
void free(void* memblock);
```
malloc은 size를 인자로 받아서 size 바이트만큼 메모리 블록을 할당한 후 해당 블록의 포인터를 반환하는 함수이다. 만일 할당할 수 있는 충분한 메모리가 존재하지 않을 경우에는 NULL을 반환하게 된다. 할당된 메모리는 프로세스가 종료되거나 직접 해제되기 전까지 계속해서 유효하게 접근될 수 있다. 결국 이런 상세 요구를 만족하기 위하여 CRT Library는 가상 메모리를 할당받아 CRT Heap을 생성한 후에 Heap 관리자를 통해서 Heap 영역의 일부를 반환하게 된다.`(163)`

Heap 영역은 할당과 미할당 영역으로 구분될 수 있다. malloc 호출시 미할당 영역에서 요청된 크기만큼을 반환하면서 반환된 영역은 할당 영역으로 변경된다. malloc 요청이 많아질 경우 할당 영역은 늘어나고, 미할당 영역은 줄어들 것이다. Heap 관리자가 malloc 요청에 대해서 반환할 미할당 영역을 찾기 어려울 때 가상 메모리를 할당하여 Heap 자체를 늘리게 되어있다. 즉, 미할당 영역을 추가로 늘리는 것이다.

free는 malloc을 통해서 할당된 메모리를 해제하는 함수이다. 인자로는 malloc을 통해서 반환된 포인터를 그대로 넣어주면 된다. free가 호출될 경우 인자 memblock이 가리키는 Heap의 할당 영역을 찾아낸 뒤에 미할당 영역으로 변경해놓는다. 만일 인근에 미할당 영역이 접해있을 경우 미할당 영역을 하나로 합치기도 한다.

malloc은 인자로 할당을 원하는 메모리 크기를 받는데 비해서 free는 해제할 메모리 크기를 인자로 받지 않는다. 그럼에도 할당된 메모리를 제대로 해제할 수 있다. 바로 추측할 수 있겠지만 Heap 관리자가 malloc으로 메모리가 할당된 내역을 저장하고 있기 때문이다. 따라서 free에 해제할 메모리 블록 포인터만 인자로 넘겨줘도 Heap 관리자가 해당 블록의 크기를 확인할 수 있고, 깨끗하게 해제를 할 수 있다.

Heap 관리자는 메모리 블록을 할당할 때마다 Heap 할당 내역을 저장하게 된다. 할당 내역 테이블에는 할당된 메모리 주소와 크기가 저장되어 있으며 free를 호출하게 될 경우 Heap 관리자는 인자로 넘어온 메모리 주소를 할당 내역에서 검색하여 존재할 경우 할당된 크기만큼 해당 메모리 블록을 해제하여 미할당 영역으로 변경한다.`(164)`

만일 free의 인자로 할당된 적이 없는 메모리 주소를 넘기게 될 경우 어떤 일이 벌어질까? MSDN에 의하면 다음의 할당 요청에 영향을 줄 수 있다고 되어있다. 이로 인해서 에러가 발생할 수 있다. 그러나 에러가 free 즉시 발생하는 것은 아니기 때문에 디버깅을 하는데 상당한 시간을 허비할 수 있다.

메모리 할당 요청 함수로 malloc을 살펴보았지만 할당 요청 함수가 malloc만 있는 것은 아니다. calloc, realloc 등도 있으며 필요에 따라서 적절히 선택하여 사용할 수 있다. 그러나 이와 같은 메모리 할당 함수를 이용하여 할당된 메모리를 해제하는 함수는 오직 free 하나 뿐이다.

### 4.2.3. new & delete
new와 delete는 C++에서 새롭게 도입된 메모리 할당 해제 연산자이다. C에서 사용하던 malloc과 free를 대신해서 사용할 수 있다. 그러나 반대로 new와 delete를 malloc과 free로 대신해서 사용할 수는 없다. 그 이유는 new와 delete가 단순하게 메모리 할당과 해제만 하는 것이 아니기 때문이다.`(165)`

malloc은 사용하기에 불편한 점이 있다. 인자로 할당할 메모리 크기를 알려주기 위해서 sizeof(type)과 같은 방법을 사용해야 된다. 또한 malloc에 의해서 반환된 포인터는 void*로서 메모리 덩어리를 가리키는 주소일 뿐이다. 따라서 의미 있는 포인터로 사용되기 위해서는 반드시 타입 변환을 수행해야 한다.`(166)`

단일 객체의 메모리 해제시 free와 delete는 별 차이가 없지만 배열 객체의 메모리 해제에서는 delete 뒤에 [] 기호가 쓰이는 차이점이 있다.

new와 delete는 malloc과 free를 단순히 쓰기 편하도록 대체하기 위해서 만든 것은 아니다. 사실 new는 내부적으로 malloc을 호출하고, delete도 역시 내부적으로 free를 호출한다. 결국 CRT Library에서 동적 메모리를 할당 해제하는 함수는 malloc과 free라고 할 수 있다. 즉, C++에서 새롭게 도입된 new와 delete는 메모리 할당과 해제는 malloc과 free에게 맡기고 나머지 추가적인 처리를 하는 연산이다. 결국 추가적인 처리를 위해서 반드시 new와 delete를 사용해야 하고 이것은 절대로 malloc과 free가 대신할 수 없다.

그렇다면 추가적인 처리란 무엇일까? 바로 생성자와 소멸자의 호출이다. 생성자와 소멸자는 C++에 클래스가 도입되면서 나타났다. 클래스 객체는 기본적으로 생성되면서 생성자가 호출되고, 사라지면서 소멸자가 호출되도록 만들어졌다.

클래스 객체가 전역 객체이거나 함수의 지역 객체일 경우 컴파일러는 어떤 클래스 타입의 객체가 생성되는지 알 수 있다. 따라서 객체 생성 과정에 생성자가 호출되도록 어셈블리를 추가한다. 그러나 클래스 객체를 malloc을 사용하여 생성할 경우 생성자를 호출할 수가 없다. malloc은 오직 인자로 받은 크기만큼 메모리를 할당하고, 해당 메모리 덩어리를 가리키는 void*만을 반환하는 함수이기 때문이다. 즉, malloc이 호출되는 순간에는 어떤 클래스 타입의 객체가 생성되는지를 알 수가 없다. 알 수 없는 클래스의 생성자를 호출할 수는 없다.

이제 소멸자를 살펴보자. 지역 객체는 main이 끝나는 시점에, 전역 객체는 프로그램이 끝나는 시점에 각각 소멸자가 호출된다. 컴파일러가 타입을 알고 있기 때문에 가능한 일이다. 그러나 free를 이용하여 동적으로 할당된 객체를 해제할 때는 소멸자를 호출할 수가 없다. 왜냐하면 free는 오직 인자로 받은 포인터의 주소를 가지고 Heap 관리자에게 해당 포인터가 가리키는 메모리 블록을 해제하는 일만 하기 때문이다. 결국 기존의 malloc과 free로는 동적 할당으로 생성되는 클래스 객체의 생성자와 소멸자를 호출할 방법이 없었고, 이를 해결하기 위해서 new와 delete를 만들게 된 것이다.`(168)`

new는 기본적으로 malloc을 통하여 메모리를 할당 받고, 할당 받은 메모리 영역에 대하여 생성자를 호출하는 역할을 수행해야 한다. 따라서 반드시 타입을 알아야만 하기 때문에 new 뒤에는 생성하고자 하는 객체의 타입이 들어가게 된다. 내부적으로는 타입의 크기를 알아내서 malloc을 호출하게 되어 있다.

delete 또한 마찬가지로 뒤에 오는 포인터의 타입이 클래스일 경우 해당 클래스의 소멸자를 호출한 후에 free를 호출하여 메모리를 해제하게 된다.

컴파일러는 대상 포인터의 타입만을 체크하여 해당 타입과 일치하는 클래스의 소멸자를 호출한 뒤에 메모리 영역을 해제하는 어셈블리를 작성한다.`(170)`

C++에 new와 delete가 도입될 수 밖에 없는 이유는 동적 생성 클래스 객체를 위해서 생성자와 소멸자를 호출하기 위한 것이다. 그렇다면 new와 delete는 클래스 타입에만 사용해야 하는데 실제적으로는 기본 타입에도 사용할 수 있다. 이는 범용적으로 사용하기 위해서이다. 타입에 따라서 new와 malloc이 혼재해서 사용되는 것은 그리 좋은 모습이 아니고 클래스라도 경우에 따라서는 효율성을 높이기 위해 생성자와 소멸자가 존재하지 않기도 하는데 이럴 경우 new와 malloc 중 어느 것을 사용해야 할지 갈피를 잡기가 힘들 수도 있다. 따라서 그런 구분은 오직 컴파일러에게만 맡기고 개발자는 new와 delete를 자유롭게 사용하기만 하면 된다.

참고로 생성자와 소멸자가 존재하지 않아도 암시적으로 생성자와 소멸자가 존재한다고 생각하는 독자도 있을 수 있는데, 여기서 말하는 것은 암시적인 생성자와 소멸자도 존재하지 않는 경우를 의미한다.

### 4.2.4. new [] & delete []
컴파일러는 어떻게 생성자와 소멸자를 2번씩 호출해야 된다는 것을 알 수 있을까? 생성자를 두 번 호출하는 것은 사실 쉽다. 하지만 문제는 소멸자를 두 번 호출하는 것이다. delete []에 전달되는 정보는 오직 배열 객체를 가리키는 포인터이다. 포인터는 말 그대로 메모리 덩어리를 가리키는 주소일 뿐이지, 이것을 통해서 배열 요소의 개수를 알아낼 수는 없다. 즉, 소멸자를 2번 부르기 위해서 컴파일러는 또 다른 마법을 부려야만 하는 것이다.`(171)`

Heap 관리자는 메모리 할당 내역을 관리하고 있으며 malloc이 호출될 경우 할당 내역에 추가되고, free가 호출되면 할당 내역에서 삭제된다. ... 할당 내역을 관리하는 자료구조는 당연히 컴파일러마다 다를 것이지만 결국 할당 내역을 통해서 검색, 추가, 삭제하는 과정은 동일하다고 할 수 있다.`(172)`

단일 객체 타입의 new와 delete의 경우 내부적으로 malloc과 free를 호출한다고 하였다. 결국 내부에서 호출되는 malloc과 free에 의해서 Heap 관리자의 할당 내역이 추가되거나 삭제될 것이다. 마찬가지로 배열 타입의 new [], delete []도 내부적으로는 malloc과 free를 호출한다. 즉, Heap 관리자의 할당 내역의 변화를 일으키는 것은 직접적으로 new와 delete가 아니라 내부에서 호출되는 malloc과 free가 된다.

단일 객체 타입의 new와 delete는 malloc과 free를 그대로 호출하는데, 배열 타입의 new [], delete []는 malloc과 free를 그대로 호출하지 않는다는 사실이다. 당연히 배열 타입이니까 다른 면이 있겠지만, 가장 큰 차이점이라고 한다면 할당 되고 해제되는 메모리의 구조 자체가 다르다는 점이다.

#### 단일 타입 new의 처리 과정
기본 타입인 int에 대해서 new를 호출할 경우 내부적으로는 malloc이 호출된다. malloc은 힙 관리자에게 메모리 할당을 요청하며, 힙 관리자는 관리하고 있는 힙에서 적절히 4바이트 만큼의 메모리 블록을 찾은 뒤에 해당 블록의 주소를 반환할 것이다. 동시에 힙 관리자는 해당 블록의 주소를 할당 내역에 추가한다. malloc을 통해서 할당 받은 메모리 블록의 주소를 new는 그대로 다시 반환한다.

#### 소멸자가 존재하는 클래스 타입의 배열 객체를 new[]를 통해서 할당하는 과정
new []를 호출하면 내부에서 malloc을 호출하는 것은 같지만, malloc으로 넘기는 인자에 변화를 준다. ... new[]의 경우 필요한 메모리 크기에 4를 더해 malloc에 요청한다. 힙 관리자는 요청 받은 만큼 힙에서 찾아내서 반환을 해줄 것이다. 그러나 반환 또한 변형이 일어나게 된다. 힙 관리자가 반환해준 주소인 Address에 4를 더한 주소를 new []는 반환한다. 그렇다면 추가적으로 요청된 4바이트 영역에는 어떤 정보가 저장되는 것일까? 바로 배열의 요소 개수가 저장되는 것이다. `(174)`

이것이 바로 배열 타입 객체의 소멸자를 배열 요소 개수만큼 호출하기 위한 마법의 근원이다.

#### delete [] 호출 후 과정
delete []의 의미는 해당 객체가 배열 타입으로 할당되었음을 나타내는 것이다. delete []가 호출 되면 컴파일러는 ptr이 가르키는 객체가 배열 타입임으로 메모리 주소에서 4를 빼고 그곳에서 바로 배열 요소의 개수를 알아낼 수 있다. 배열 요소의 개수를 알아내면 그만큼 반복하면서 소멸자를 호출하면 된다. 동시에 메모리를 해제하기 위하여 내부적으로 free를 호출할 때도 ptr가 가르키는 주소에서 4를 뺀 값을 인자로 넘기게 되어있다. 당연히 힙 관리자는 할당 내역에서 할당 정보를 찾을 수 있고, 정확하게 해재할 수 있다.

delete []가 아니라 delete를 호출할 경우 컴파일러는 단순히 소멸자는 한번만 호출할 것이며, ptr 주소를 그대로 free에 인자로 넘기게 된다. 그러나 힙 관리자는 할당 내역에서 주소를 찾을 수 없기 때문에 메모리는 제대로 해제되지 않게 된다. 이런 상황을 보통 힙 충돌이 발생했다고 하는데 힙 충돌은 즉시 오류를 발생시킬 수도 있지만, 보통 나중에 더 큰 오류의 원인으로 작용하기 때문에 디버깅을 상당히 어렵게 만든다.

#### 소멸자가 존재하지 않는 타입에 대한 new []할당
소멸자를 부를 필요가 없기 때문에 배열의 요소 개수를 저장할 추가 영역 4바이트가 불필요하게 된다. `(175)`

단일 객체 할당을 위한 new와 크게 다를 것이 없다. ... 바로 delete와 delete []의 구분이 무의미하다는 것이다. 

예제에서 사용된 클래스 CTest는 명시적으로 소멸자가 존재하지 않는다. 그렇다고 컴파일러에 의해서 암시적으로 소멸자가 생성되느냐? 그것도 아니다. 상식적으로 생각할 때 컴파일러가 암시적으로 소멸자를 만들 필요가 없다. 그러나 컴파일러는 정말 필요할 겅여 암시적 소멸자를 생성하기도 한다. 예를 들어 부모 클래스에 명시적 소멸자가 있고 자식 클래스에는 명시적 소멸자가 없을 경우 부모 클래스의 소멸자를 호출하기 위해서 암시적인 소멸자가 생성되게 된다`(177)`

### 4.2.5. Placement new
이해할 수 없는 내용


## 4.3. 메모리와 이름
프로그래밍에 있어서 메모리를 다루는 것은 정말 중요한 일이다. C/C++의 경우 메모리에 접근하기 위하여 포인터를 사용한다. 포인터가 C/C++에서 절대적인 위치를 차지하고 있기는 하지만 사실 포인터는 메모리를 좀더 쉽게 다루기 위한 하나의 수단일 뿐이지, 절대적인 것은 아니다. 이미 자바를 비롯하여 포인터를 사용하지 않는 프로그래밍 언어는 많이 존재하고 있다. 즉, 포인터가 없더라도 메모리에 접근할 수 있는 방법은 이미 존재하고 있는 것이다. `(185)`

... 결국 메모리를 다룸에 있어서 해당 메모리 블록에 이름을 붙여서 사용한다. 왜냐하면 이름을 붙여서 사용하는 것이 가장 인간이 편안함을 느끼는 방식이기 때문이다.

변수를 정의한다는 것은 메모리 블록을 사용하겠다는 것이다. ... 결국 크기를 가지면서 연속된 메모리 영역을 메모리 블록이라고 할 수 있다.

메모리 블록을 구분하기 위해서 필요한 것은 메모리 블록의 주소와 크기가 될 것이다. 

이제 메모리 블록은 [주소, 크기, 상태]로 구성될 수 있따. 여기서 주소와 크기는 메모리 블록을 구분할 수 있는 실질적인 것이며, 상태는 실제로 메모리 블록의 비트들의 On/Off 상태를 나타내는 것이라고 할 수 있다. `(187)`

예제처럼 변수를 정의한다는 것은 변수 이름을 통해서 메모리 블록을 생성하겠다는 의미이다. ... 타입을 통해서 생성할 메모리 블록의 크기가 정해지게 되며, 타입을 통해서 메모리 블록의 비트 상태를 해석하여 의미(값)를 파악할 수도 있으며 반대로 특정 의미(값)를 가지도록 메모리 블록의 비트 상태를 결정할 수도 있다.

### 4.3.3. l-value로 사용되는 이름
프로그래밍에는 l-value와 r-value라는 개념이 있다. MSDN에 의하면 모든 C++의 식은 l-value 또는 r-value이며, l-value는 단일 식을 넘어 지속되는 개체를 가리키고, r-value는 유지되지 않는 임시 값을 나타낸다. `(189)`

바로 메모리 블록의 이름이 l-value로 사용될 수 있기 때문이다.

메모리 블록이기 때문에 주소를 가질 수 있따. 모든 변수가 l-value라는 것은 각각의 변수가 주소를 가지고 있기 때문이다. 그에 비해서 상수는 절대로 l-value가 될 수 없다. 상수가 특정 메모리 영역을 차지하는 경우도 있지만, 상수 자체가 주소를 나타내지는 않기 때문이다. 무슨 의미인가 하면 어떤 상수 C가 메모리 10번지, 20번지에 있을 경우, 상수C 자체는 10번지 20번지라는 특정 주소를 나타낼 수 없기 때문이다. `(190)`

일반적으로 메모리 블록의 이름은 l-value로 사용될 수 있다. 그러나 int arr[1]={1};에서 arr은 l-value가 아니다. arr이 메모리 블록을 나타내는 이름이긴 하지만 arr을 통해서 값을 설정할 수 없기 때문이다. ... 배열 이름이나 함수 이름은 l-value로 사용될 수 없다. `(191)`

### 4.3.4. r-value로 사용되는 이름(값)
... 메모리 블록의 이름은 l-value 혹은 값으로 사용될 수 있었다. ... 메모리 블록의 이름은 r-value로서 사용될 수도 있는 것이다. 중요한 것이 있는데, 여기서 말하는 r-value는 바로 메모리 블록의 비트 상태가 나타내는 값으로서의 r-value이다. `(192)`

### 4.3.5. r-value로 사용되는 이름(주소)
일반적으로 메모리 블록의 이름은 l-value와 r-value로 사용된다. 하지만 이름이 l-value로 사용될 수 없는 경우도 있다. 또한 이름이 r-value로 사용되긴 하지만 메모리 블록의 비트 상태가 나타내는 값으로서의 r-value가 아니라 다른 의미의 r-value인 경우도 있다. ... 바로 배열 이름과 함수 이름이다. 배열 이름과 함수 이름은 공통점이 있는데, l-value로 사용되지 않으며, r-value로만 사용되는데 그 r-value의 의미는 바로 메모리 블록의 주소를 나타낸다는 것이다.

배열 이름은 오직 배열 객체의 메모리 블록 주소를 나타낸다. 따라서 배열 이름은 l-value가 될 수 없다. `(193)`

```cpp
int arr[1] = {1};
```
arr이 바로 배열 이름이다. 그런데 식에서 값 {1}을 대입하고 있다. 즉, arr이 l-value로 사용되고 있는 것 같다. 그러나 이를 arr이 l-value로써 사용된다고 해석하는 것은 옳지 않다. 해당 식은 배열 객체의 초기화 식이다. 무슨 의미인가 하면 어떤 메모리 블록을 마련해서 1이라는 값을 채워놓은 뒤에, 그 블록의 이름을 arr라고 지정한다는 것이다. 즉, arr이라는 블록을 미리 마련하고 arr이라는 이름을 통해서 1을 대입하는 것이 아니라, 1이 채워진 메모리 블록의 이름을 arr이라고 부르기로 한 것이다. 순서가 바뀐 것이지만 분명한 의미의 차이가 있다.

배열 이름과 더불어서 함수 이름도 l-value로 사용될 수 없으며, r-value로 사용될 때는 함수본체의 메모리 주소를 나타낸다. 함수 이름이 나타내는 메모리 블록의 비트 상태 값은 바로 함수 본체를 표현하는 기계어 코드일 뿐이다.

```cpp
void func(void) {};

if (func == &func)
{
    //something
}
```
func는 함수 이름이기 때문에 주소 연산자 &를 이용하여 이름과 비교할 경우 이름이 곧 주소라는 것을 확인할 수 있다. `(195)`

한가지 주의할 점이 있는데 멤버 함수의 경우 함수 이름이 주소를 나타내는 r-value로 사용될 수 없다는 점이다. ... 따라서 명시적으로 함수 본체의 주소를 사용하겠다는 & 연산자를 사용해야만 주소로서 인정하겠다는 의도가 있다.

왜 배열과 함수 이름은 l-value로 사용될 수 없으며, r-value 또한 메모리 블록의 비트 상태를 나타내는 것이 아니라 주소를 나타내는 것일까? 상식적으로 생각하면 무척 쉽게 이해할 수 있다. 배열의 경우 같은 타입의 객체들의 모임이다. ... 배열 객체의 전체 값이라는 개념은 의미를 가지기에 애매한 점이 있다. 따라서 배열 객체에 있어서 메모리 블록의 비트 상태를 해석한 r-value 자체가 무의미하다고 할 수 있다. 그래서 배열 이름은 단일 객체와는 달리 메모리 블록의 주소를 나타내도록 한 것이다. 따라서 배열 이름이 나타내는 r-value 역시 주소를 나타내게 된 것이다. `(196)`

함수도 메모리 블록이 존재한다. 함수에 있어서 값이란 그저 함수 본체일 뿐이다. 즉, 함수 본체 자체를 r-value로서 사용하는 것은 의미가 없다. 그래서 함수 이름 역시 배열과 마찬가지로 메모리 블록의 주소를 나타내도록 한 것이다.

이런 견해에 대하여 애매모호한 타입이 하나 있다. 바로 클래스이다. 클래스는 다른 타입의 객체들이 모여있는 타입이라고 생각할 수 있다. 따라서 배열과 속성이 일맥상통하지만 클래스 객체 이름은 l-value로써 사용된다.

메모리 블록의 이름에 대해서 정리를 하자. 메모리 블록의 핵심 요소는 바로 주소와 크기이다. 그러나 주소와 크기만으로 메모리 블록을 다루는데 어려움이 있기 때문에 이름을 도입한 것이다. 이름은 여러 용도로 사용될 수 있는데, 대표적으로 l-value와 r-value로 사용된다. 보통 변수 이름이 l-value로인데 l-value를 통해서 메모리 블록의 비트 상태, 즉 값을 설정할 수 있다. 또한 l-value로 사용되는 이름은 r-value로 사용되기도 하는데, 이때 r-value는 메모리 블록의 비트 상태인 값을 나타낸다. 메모리 블록의 이름 중에는 l-value로 사용 될 수 없는 경우도 있다. 대표적으로 배열 이름과 함수 이름이다. 그러나 r-value로 사용될 수는 있는데, 이때 r-value는 메모리 블록의 비트 상태를 나타내느 것이 아니라, 메모리 블록의 주소를 나타낸다.

## 4.4. 정리
메모리란 바로 가상 메모리를 의미한다는 것을 확실히 알고 있어야만 한다.`(197)`

현재 프로그래밍의 주 관심사는 안전이다. 프로그램이 생명과 직결되는 분야에까지 적용되고 있기 때문이다. 안전한 프로그래밍을 하기 위해서는 제일 첫째가 메모리를 안전하게 잘 다루는 것이다. 그러기 위해서는 더욱 메모리를 잘 알아야만 하고 효율적으로 사용해야 한다.


# Chapter 05 포인터와 배열
포인터란 무엇일까? 보통 메모리 주소를 나타낸다고 생각하지만 객체가 존재하는 메모리 블록을 가리킨다고 보는 편이 더 낫다. 만일 메모리 주소만을 나타내느 것이 목적이었다면 타입별로 포인터 타입이 따로 존재할 필요가 없기 때문이다. `(198)`

배열은 같은 타입의 객체를 차례대로 일렬로 모아놓은 자료구조이다. 가상 메모리에서 볼 때 객체들이 일렬로 연속적으로 존재한다. 주소가 연속적이므로 배열의 특정 객체를 접근하는데 필요한 시간 복잡도는 오직 상수 시간이다.

배열의 객체들이 연속적으로 이어지는 특성으로 인하여 C/C++에서는 포인터로 배열을 다룰 수가 있따. 포인터와 배열은 비슷한 면이 있어서 배열을 포인터처럼 혹은 포인터를 배열처럼 사용하기도 한다. 그러나 둘은 명백히 다른 것이기 때문에 자칫 잘못 사용하면 큰 낭패를 당할 수가 있다. `(199)`

## 5.1. 포인터
메모리의 주소를 가리키는 객체를 포인터라고 부른다. ... 메모리 블록은 주소, 크기, 상태와 같은 정보를 가지고 있다. 만일 포인터가 메모리 블록의 주소만을 나타낸다면 해당 블록에 접근하여 값을 가져오거나 쓰고자 할 경우 블록의 크기와 타입을 고려하여 프로그래밍을 해야 하는 수고를 들여야만 한다. 따라서 메모리 블록을 쉽게 관리(읽기, 쓰기)할 수 있도록 포인터에는 주소뿐 아니라 타입 정보까지 들어가게 되었다. `(200)`

### 5.1.1. 포인터타입
포인터 타입과 가르키는 객체의 타입이 동일하면 사용이 쉽고 편해서 장점이 많다는 것이지, 반드시 동일 타입을 사용할 필요는 없다. 필요에 따라서 다른 타입의 포인터를 사용해 객체를 가리킬 수도 있다.

... 포인터도 역시 객체라는 점이다. 

포인터의 원천 타입은 포인터가 가리키는 메모리 주소로부터 타입 크기만큼의 블록을 타입을 기준으로 읽고, 쓰기 위해서 사용된다. 즉, TYPE* ptr가 나타내는 의미는 ptr가 가리키는 주소를 기준으로 sizeof(TYPE)의 크기의 블록의 비트 상태를 TYPE에 의해서 의미(값)을 부여하여 대응시키겠다는 것이다. 따라서 ptr을 통해서 해당 블록의 값을 읽거나 쓸 수 있다. `(203)`

### 5.1.2. 타입 표기
포인터 타입을 만드는 규칙은 다음과 같다.

원천 타입의 객체를 선언한다. 객체의 이름을 간접(\*) 연산자로 변경한다. 필요한 경우 간접(\*)연산자를 괄호()로 감싸서 우선 순위를 맞춘다. 마지막 세미콜론(;)을 제거한다. `(207)`

### 5.1.3. 포인터와 주소 대응
포인터는 메모리 블록의 주소를 나타낸다. 주소를 나타내기 때문에 포인터는 0을 포함하는 자연수를 나타낸다고 할 수 있다. ... 포인터는 정수형 타입처럼 연산을 수학적인 방식으로 해석하지 않고 포인터 방식으로 연산을 처리한다. `(208)`

### 5.1.4. 포인터 연산자
포인터를 통해서 메모리의 원하는 주소로부터 원하는 크기의 블록을 원하는 타입으로 다룰 수 있게 되었다. C/C++는 포인터를 통하여 메모리를 쉽게 다룰 수 있도록 하기 위하여 다양한 연산자를 제공하고 있다.

#### 5.1.4.1. 간접(\*)연산자 - Indirect Operator
포인터가 직접 가리키는 것은 메모리 주소이다. 메모리의 주소를 통해서 간접적으로 메모리 블록을 나타내기 때문에 '간접'이란 뜻을 사용한 것이라고 생각된다.

간접(\*) 연산자는 포인터 앞에 붙어서 포인터가 가리키는 메모리 블록을 나타낸다.`(210)`

#### 5.1.4.2. 간접 멤버($\rightarrow$) 연산자 - Arrow operator
이포인터가 가리키는 메모리 주소를 통해서 간접적으로 클래스 객체의 멤버를 나타낸다는 의미이다. 참고적으로 포인터가 아닌 클래스 객체에서는 멤버를 나타내기 위하여 직접 멤버(.) 연산자를 사용한다. 한마디로 간접 멤버 연산자($\rightarrow$)는 직접 멤버 연산자(.)의 포인터 판인 셈이다.

#### 5.1.4.3. 증감(++,--) 연산자 - Increment & Decrement Operator
#### 5.1.4.4. 첨자 연산자([]) - Subscript Operator
첨자 연산자를 사용하면 포인터를 배열처럼 사용할 수 있따. ... 인덱스가 유효한 경우에만 사용되도록 주의를 기울여야 한다. 첨자 연산자에 사용되는 인덱스는 포인터의 증감 연산자와 마찬가지로 포인터의 원천 타입 크기만큼씩 주소를 이동시키는 역할을 한다. ... 참고로 인덱스는 일반적으로 0부터 시작하지만 음수가 될 수도 있다. 이때는 주소가 감소하는 방향으로 이동하게 된다.

# Chapter 08 가상 함수
## 8.1. 가상 함수 기본 동작
정적 멤버 함수도 가상 함수가 될 수 없다. `(616)`

한 번 가상 함수로 선언되면 자식 클래스에서 재정의되는 함수도 가상 함수가 된다.

## 8.2. 가상 함수 테이블
비가상 멤버 함수나 가상 함수는 함수 그 자체로서는 큰 차이가 없다. 메모리 코드 영역의 어딘가에 위치할 뿐이다. 컴파일러는 당연히 모든 함수들의 메모리 시작 위치를 파악하고 있다. 비가상 멤버 함수가 호출될 때 컴파일러는 해당 함수의 시작 주소를 call 하도록 어셈블리 코드를 작성할 뿐이다. `(624)`

가상함수는 추가적인 구조가 필요하다. 일단 클래스 객체의 시작 위치에 vfptr 영역이 생성된다. 이것의 이름은 Virtual Function Table Pointer이다. 말 그대로 가상 함수 테이블을 가리키는 역할을 한다.

가상함수테이블의 각 항목은 함수 본체를 가리키는 포인터가 되는 것이다.

비가상 멤버 함수의 경우 컴파일러는 지겁 해당 함수의 메모리 주소로 call을 수행하게 어셈블리 코드를 작성하는 것이다. `(625)`

32비트 x86 시스템 기준 가상함수 call 어셈블리어 소개 `(626)`
```c++
mov eax,dword ptr [pT]  //pT가 가리키는 메모리 주소를 eax에 넣어라.
                        //레지스터가 아닌 변수 이름이 직접 사용될 경우는 변수의 값 자체를 읽게 된다
                        //pT는 Derive 객체를 가르키는 Base ptr이다.
mov edx,dword ptr [eax] //eax가 가리키는 곳의 4바이트 값을 읽어서 edx에 넣어라.
                        //edx는 Derive 객체의 vfptr이 된다.
mov eax,dword ptr [edx] //edx가 가리키는 곳의 4바이트 값을 읽어서 eax에 넣어라.
                        //eax는 vfptr의 첫번째 항목의 포인터가 된다. (함수 본체를 가리키고 있음)
call eax                //eax가 가리키는 곳으로 점프하여 실행하여라.
```

### 8.2.2. 가상 함수 테이블 생성
컴파일러는 컴파일 시점에 소스 코드에 정의된 모든 클래스에 대해서 가상 함수가 하나라도 있을 경우 가상 함수 테이블을 생성한다. 그리고 각 클래스의 객체가 생성될 때 객체의 시작 주소에 vfptr을 생성하고 해당 클래스의 가상 함수 테이블의 주소값을 갖게 한다.

## 8.3. 상속 클래스의 가상 함수

### 8.3.1. vfptr 초기화
Derive class에서 가상 함수를 재정의 한 경우, Base class의 가상 함수 테이블에는 Base class 가상함수의 주소가 들어가고 Derive class의 가상 함수 테이블에는 Derive class 가상함수의 주소가 들어가있다. `(630)`

만약 Derive class에서 가상 함수를 재정의 하지 않을 경우, Derive class의 가상 함수 테이블에는 Base class 가상 함수의 주소가 들어가게 된다. 

Derive class의 객체를 생성할 경우, 하나의 vfptr만 존재한다. 

클래스의 vfptr은 클래스 객체의 메모리 시작 위치에 있어야만 한다.

Derive class의 객체를 생성할 경우, 먼저 Base class의 생성자가 호출이 되며 이때 vfptr은 Base class의 가상 함수 테이블의 주소값을 갖게 된다. 이후 Derive class의 생성자가 호출이 되고 최종적으로 vfptr은 Derive class의 가상 함수 테이블의 주소값을 갖게 된다.

Base*로 Derive 객체를 가르키더라도, Derive 객체의 vfptr은 이미 Derive class의 가상 함수 테이블을 가르키고 있다. `(631)`

컴파일러가 가상 함수 테이블을 생성할 때는 이 가상함수와 인덱스를 묶어서 기억한다. 즉, 어떤 가상함수 f가 가상 함수 테이블의 2번째 항목에 들어간다면 인덱스 1과 묶여 (f,1)과 같은 정보가 컴파일러 내부에 기억된다. 그 후에 컴파일러는 가상 함수를 인덱스로 치환하여 처리한다. 

Derive 객체를 가르키는 Base*로 가상함수를 호출할 경우, 컴파일러는 내부에 저장된 값을 통해 가상함수의 인덱스를 알아낸다. 다음 vfptr을 통해 가상함수 테이블의 알아낸 인덱스에 저장된 함수를 호출하도록 어셈블리 코드를 작성한다. 즉, 가상 함수는 오직 vfptr이 가리키는 가상함수테이블과 가상 함수의 인덱스 정보만으로 주소를 찾아내서 호출할 수 있다.

### 8.4. 가상 함수의 호출 방식
가상 함수는 함수 자체로서만 따진다면 비가상 멤버 함수에 비해서 특별한 차이가 있는 것은 아니다. 엄연히 메모리 코드 영역에 보통의 함수처럼 똑같이 존재하기 때문이다. 단지 차이가 있다면 가상 함수와 비가상 멤버 함수는 호출하는 방식이 다르다는 것뿐이다. `(634)`

#### 8.4.1. 직접 멤버(.) 연산자, 간접 멤버(->) 연산자
참조 타입이기 때문에 객체가 새로 생성되는 것이 아니라 기존 객체의 Base 부분을 가리키는 것뿐이다. `(636)`

암시적인 복사 생성자의 동작은 기본 타입에 대해서 메모리 복사를 수행한다. 따라서 Derive의 vfptr의 값이 Base의 vfptr로 복사될 수 있다. 그러나 C++에서는 기본 타입의 메모리 복사에서 vfptr은 제외시킨다.

Derive 클래스 객체에서 Base 클래스 객체로 단순 값 복사를 위하여 memcpy를 사용 하는 경우도 있는데, memcpy는 강제적으로 vfptr을 복사하기 때문에 상당히 위험하다. `(637)`

범위 연산자를 사용할 경우 가상 함수는 비가상 멤버 함수처럼 호출된다. `(640)`

## 8.5. 생성자와 소멸자

### 8.5.1. virtual 소멸자
소멸자는 상속되지 않는다. 상속이 되지 않기 때문에 재정의도 불가능하다. ... 즉, 부모 클래스의 소멸자와 자식 클래스의 소멸자는 별 상관 없는 멤버 함수라고 보는 것이 더 합당하다. 그러나 소멸자가 가상함수로 지정될 때는 마치 소멸자가 상속되면서 재정의되는 함수처럼 여겨진다. `(642)`

delete를 사용할 경우 destructor(파괴자)라는 함수가 호출되고, 그 안에서 Base::~Base를 또다시 호출한다. 그러나 스택에서 객체가 해제될 경우에는 바로 Base::~Base가 호출된다. 파괴자는 클래스의 소멸자를 호출해준 뒤에 바로 Heap에 생성된 클래스 객체 메모리를 해제하는 역할을 한다. `(643)`

소멸자는 메모리 해제를 하지 않는다. 소멸자는 객체가 메모리에서 해제되기 직전에 정리할 것이 있따면 정리를 하는 것뿐이다. 그렇다면 파괴자는 소멸자를 먼저 호출해 준 후에 실제 메모리 영역을 힙으로부터 반환해주는 역할을 수행한다. ...즉, delete->파괴자->소멸자 순서로 진행된다.

컴파일러는 모든 클래스에 대하여 파괴자를 멤버 함수로서 암시적으로 추가하며, 각 파괴자는 자신이 소속된 클래스의 소멸자를 호출하도록 정의된다. `(644)`

소멸자에 virtual 키워드를 붙일 때 실제로는 파괴자를 가상 함수로 지정하는 것이다. 따라서 실제 Vtable의 항목에 소멸자의 주소를 넣는 것이 아니라 소멸자를 부르는 파괴자의 주소를 대신 넣는것이다. 그래서 Base의 소멸자와 Derive의 소멸자가 이름이 다르더라도 실제 VTable에 들어가는 파괴자의 이름은 같기 때문에, 마치 소멸자들이 일반 멤버 함수처럼 가상 함수로 동작할 수 있는 것이다.

### 8.5.2. 생성자와 vfptr
vfptr의 값이 생성자에서 초기화되는 것을 확인하였다.

Base 객체의 생성자 안에서 가상 함수를 호출할 경우, Base 객체의 생서자 호출전 선처리 과정에서 vfptr은 Base의 가상함수테이블을 가르키고 있다. 따라서 가상 함수를 호출할 경우 Base의 가상함수테이블에 의해 Base의 가상함수가 호출 된다. ... Derive 객체의 생성자 안에서 가상 함수를 호출한 경우 vfptr은 Derive의 가상함수 테이블을 가르키고 있다. 따라서 가상 함수를 호출할 경우 Derive의 가상함수 테이블에 의해 Derive의 가상함수가 호출 된다. `(652)`

생성자 안에서 가상 함수의 호출은 비가상 멤버 함수를 호출하는 것처럼 동작한다.

### 8.5.3. 소멸자와 vfptr




