#ifndef __MEC_SIMPLE_VECTOR_H
#define __MEC_SIMPLE_VECTOR_H

#include "MecVectorRef.h"
// #include "tbb/scalable_allocator.h" //(lkb1024-vec)

namespace Mec {

template <typename data_type,size_type n>
class MiniVector; 

template <typename data_type>
class SimpleVector : public VectorRef<data_type> {
public:
  typedef data_type            EntryType;
  typedef data_type            T_numtype;
  typedef SimpleVector         T_array;
  typedef VectorRef<data_type> VectorRefType;
  typedef data_type*           iterator;
  typedef const data_type*     const_iterator;
  typedef VectorRef<data_type> VectorRangeType;

private:
  typedef SimpleVector ThisVectorType;

protected:
  SimpleVector(const data_type* _RESTRICT data,size_type sz):VectorRef<data_type>(data,sz) {} // intentional
  //SimpleVector(const SimpleVector<data_type>& src):VectorRef<data_type>(src.data(),src.size()) {}

public:
  SimpleVector(void):VectorRef<data_type>() {}
  //SimpleVector(const data_type* _RESTRICT data,size_type sz):VectorRef<data_type>(data,sz) {} // intentional
  explicit SimpleVector(size_type size):VectorRef<data_type>(VectorRef<data_type>::alloc_data_(size),size) {}
  // copy constructor of SimpleVector should be defined explicitly 
  SimpleVector(const SimpleVector<data_type>& src):VectorRef<data_type>() { VectorRef<data_type>::copy_vec(*this,src); }
  //explicit SimpleVector(const VectorRef<data_type>& src):VectorRef() { copy_vec(*this,src); }

  ~SimpleVector(void) { clear(); }

//  VectorRef& all_range(void) { return *static_cast<VectorRef*>(this); }

  // copy operator of SimpleVector should be defined explicitly 
  // otherwise, default copy operator generated by compiler (member-wise copy) will be called
  SimpleVector<data_type>& operator=(const SimpleVector<data_type>& src) { return VectorRef<data_type>::copy_vec(*this,src); }
  // should be resized
	template <size_type n>
	SimpleVector<data_type>& operator=(const MiniVector<data_type, n>& src) { return VectorRef<data_type>::copy_vec(*this,src); }
  SimpleVector<data_type>& operator=(const VectorRef<data_type>& src) { return VectorRef<data_type>::copy_vec(*this,src); }
  SimpleVector<data_type>& operator=(const SparseVector<data_type>& src) { return VectorRef<data_type>::copy_vec(*this,src); }


  //CommaAssignment<data_type>  operator=(const data_type& val) { return VectorRef::operator=(val); }
  DEF_VEC_COMMA_ASSIGNMENT

  DEF_VEC_VEC_OPR(+=)
  DEF_VEC_VEC_OPR(-=)
  DEF_VEC_VEC_OPR(*=)
  DEF_VEC_VEC_OPR(/=)

  DEF_VEC_SCAL_OPR(+=)
  DEF_VEC_SCAL_OPR(-=)
  DEF_VEC_SCAL_OPR(*=)
  DEF_VEC_SCAL_OPR(/=)

  //VectorRef<data_type>& operator+=(const VectorRef<data_type>& dr) { return VectorRef::operator+=(dr); }
  //VectorRef<data_type>& operator+=(const data_type& val) { return VectorRef::operator+=(val); }

  //VectorRef<data_type>& operator-=(const VectorRef<data_type>& dr) { return VectorRef::operator-=(dr); }
  //VectorRef<data_type>& operator-=(const data_type& val) { return VectorRef::operator-=(val); }

  void resize(size_type size) { VectorRef<data_type>::resize_(size); }
  void resize_preserve(size_type size) { VectorRef<data_type>::resize_preserve_(size); }
  void clear(void) { VectorRef<data_type>::clear_(); } 
  void free(void) { VectorRef<data_type>::clear_(); }
};




//// memory managers for SimpleVector defined in VectorRef

template <typename data_type>
inline data_type* VectorRef<data_type>::alloc_data_(size_type size)
{ 
  if(size==0) return NULL; 
  return (new data_type[size]); 
  //return (data_type*) scalable_aligned_malloc(size*sizeof(data_type),_MEM_ALIGN_BND); //(lkb1024-vec)
}

//template <>
//inline real_type* VectorRef<real_type>::alloc_data_(size_type size)
//{
//  if(size==0) return NULL;
//  real_type* ptr=(real_type*)ALIGNED_MALLOC(size*sizeof(real_type));
//  if(ptr==NULL) throw std::bad_alloc();
//  return ptr;
//}
//
//template <>
//inline idx_type* VectorRef<idx_type>::alloc_data_(size_type size)
//{
//  if(size==0) return NULL;
//  idx_type* ptr=(idx_type*)ALIGNED_MALLOC(size*sizeof(idx_type));
//  if(ptr==NULL) throw std::bad_alloc();
//  return ptr;
//}

template <typename data_type>
inline void VectorRef<data_type>::free_data_(data_type** ptr)
{
  if(*ptr) {
    delete[] *ptr;
    //scalable_aligned_free((void*) *ptr); //(lkb1024-vec)
    *ptr=NULL;
  }
}

//template <>
//inline void VectorRef<real_type>::free_data_(real_type* ptr)
//{
//  if(ptr) ALIGNED_FREE(ptr);
//}
//
//template <>
//inline void VectorRef<idx_type>::free_data_(idx_type* ptr)
//{
//  if(ptr) ALIGNED_FREE(ptr);
//}

template <typename data_type>
inline void VectorRef<data_type>::clear_(void) 
{ 
  free_data_(&_data);
  _size=0; 
} 

template <typename data_type>
inline void VectorRef<data_type>::resize_(size_type size) 
{ 
  if(size!=_size) {
    free_data_(&_data);
    _data=alloc_data_(size);
    _size=size;
  }
}

template <typename data_type>
inline void VectorRef<data_type>::resize_preserve_(size_type size) 
{ 
  if(size!=_size) {
    data_type* tdata=_data;
    _data=alloc_data_(size);
    idx_type iend=std::min(size,_size)-1;
    if(iend>=0) {
      range(*this,0,iend)=VectorRef(tdata,0,iend);
    }
    free_data_(&tdata);
    _size=size;
  }
}

//typedef SimpleVector<idx_type> IdxSVector;
//typedef SimpleVector<tag_type> TagSVector;
typedef SimpleVector<real_type> RealSVector;
typedef SimpleVector<idx_type>  IdxSVector;
typedef SimpleVector<tag_type>  TagSVector;
typedef SimpleVector<IdxSVector> ThrSpcIdx;
typedef SimpleVector<bool>      ThrSpcBool;

DEF_SHARED_PTR(RealSVector)
DEF_SHARED_PTR(IdxSVector)

}	// namespace Mec

#endif